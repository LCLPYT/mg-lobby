import net.fabricmc.loom.task.RemapJarTask
import work.lclpnet.build.task.GithubDeploymentTask

import java.util.stream.Stream

plugins {
    id 'java'
    id 'fabric-loom' version '1.3.8'
    id 'maven-publish'
    id 'gradle-build-utils' version '1.5.3'
    id 'kibu-plugin-dev' version '0.11.0'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

Properties props = buildUtils.loadProperties('publish.properties')

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

group = project.maven_group
version = buildUtils.gitVersion()
archivesBaseName = project.archives_base_name

if (props.containsKey('versionOverride')) {
    version = props.get('versionOverride')
}

repositories {
    mavenCentral()

    maven {
        url 'https://repo.lclpnet.work/repository/internal'
    }

    maven {
        url = 'https://maven.nucleoid.xyz/'
    }
}

// list of extra source set names that will have minecraft classpath and will be available in the main source set
def extraSourceSets = ['activity', 'game', 'dev']
// list of extra source set names that should not be merged into the produced artifacts ("localRuntimeOnly")
def localExtraSourceSets = ['dev']
// list of extra source set names that should have their own standalone jar artifact
def artifactExtraSourceSets = ['activity']

extraSourceSets.each {
    sourceSets.register(it).configure {
        // make sourceSet classes available in the main sourceSet
        sourceSets.main.compileClasspath += it.output
    }
}

sourceSets {
    dev.compileClasspath += game.output
}

dependencies {
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
    modImplementation "work.lclpnet.mods.kibu:kibu:${project.kibu_version}"
    modImplementation "work.lclpnet.mods.kibu:kibu-plugins:${project.kibu_plugins_version}"
    modImplementation "xyz.nucleoid:fantasy:${project.fantasy_version}"
    pluginImplementation "work.lclpnet.mcserver-api:mcserver-api-kibu:${project.mcserver_api_version}"
    pluginLocalRuntime "work.lclpnet.plugins:pal:${project.pal_version}"

    implementation 'com.google.code.findbugs:jsr305:3.0.2'
    implementation 'org.json:json:20230227'
    implementation'com.google.dagger:dagger:2.46.1'
    annotationProcessor 'com.google.dagger:dagger-compiler:2.46.1'

    // bundle these dependencies
    'work.lclpnet:json-config4j:1.0.0'.with {
        implementation it
        bundle (it) { transitive = false }
    }

    'org.apache.commons:commons-compress:1.23.0'.with {
        implementation it
        bundle it
    }

    'org.tukaani:xz:1.9'.with {
        implementation it
        bundle it
    }

    'org.apache.tika:tika-core:2.5.0'.with {
        implementation it
        bundle it
    }

    "work.lclpnet:maze-lib:${project.maze_lib_version}".with {
        implementation it
        bundle (it) { transitive = false }
    }

    // test dependencies
    testImplementation "net.fabricmc:fabric-loader-junit:${project.loader_version}"
    testImplementation "org.mockito:mockito-core:5.6.0"
}

loom {
    serverOnlyMinecraftJar()

    runs {
        remove client
    }
}

test {
    useJUnitPlatform()
    systemProperty('fabric.side', 'server')
}

java {
    withSourcesJar()
}

tasks.withType(JavaCompile).configureEach {
    it.options.release.convention(17)
}

processResources {
    // replace placeholders in resources
    inputs.property "version", project.version

    filesMatching("plugin.json") {
        expand "version": project.version
    }
}

// add main dependencies to the extra sourceSets
extraSourceSets.each { name ->
    configurations.named("${name}Implementation").configure {
        it.extendsFrom(configurations.implementation)
    }

    configurations.named("${name}CompileClasspath").configure {
        it.extendsFrom(configurations.modCompileClasspathMapped)
    }

    configurations.named("${name}RuntimeClasspath").configure {
        it.extendsFrom(configurations.modCompileClasspathMapped)
    }

    // add minecraft dependencies to extra sourceSet (only available after project evaluation)
    afterEvaluate {
        configurations.named("${name}CompileClasspath").get().extendsFrom(configurations.minecraftNamedCompile)
        configurations.named("${name}RuntimeClasspath").get().extendsFrom(configurations.minecraftNamedRuntime)
    }

    kibu {
        // add extra source sets to the dev plugin loader
        pluginPaths.from(sourceSets.named(name).get().output)
    }

    def set = sourceSets.named(name).get()

    sourceSets.named('test').configure {
        it.compileClasspath += set.output
        it.runtimeClasspath += set.output
    }

    if (!localExtraSourceSets.contains(name)) {
        tasks.named("process${name.capitalize()}Resources").configure {
            tasks.processResources.dependsOn(it)  // should process activity resources
        }

        // include extra sourceSet in main jar tasks
        [jar, sourcesJar, shadowJar].each {
            it.from set.output
        }
    }
}

def licenseJarTasks = [jar, sourcesJar, shadowJar]

artifactExtraSourceSets.each { name ->
    // add extra jar tasks
    def defaultJar = tasks.register("${name}Jar", Jar.class) {
        from(sourceSets.named(name).get().output)
        archiveClassifier.set("${name}-dev")
        destinationDirectory.set(new File(buildDir, "devlibs"))

        description "Builds the standalone ${name} api jar."
        group 'build'
    }.get()

    def remappedJar = tasks.register("remap${name.capitalize()}Jar", RemapJarTask.class) {
        dependsOn defaultJar

        description "Remaps the built ${name} jar to intermediary mappings."
        group 'fabric'
        archiveClassifier.set(name)

        inputFile.convention(defaultJar.archiveFile)
    }.get()

    [defaultJar, remappedJar].each {
        tasks.assemble.dependsOn(it)
    }

    licenseJarTasks.add(defaultJar)
}

// include license file in jar tasks
licenseJarTasks.each {
    it.from('LICENSE') {
        rename { "${it}_${project.archivesBaseName}" }
    }
}

shadowJar {
    mergeServiceFiles()
}

def env = System.getenv()

tasks.register("github", GithubDeploymentTask) {
    dependsOn tasks.remapShadowJar

    config {
        token = env.get("GITHUB_TOKEN")
        repository = env.get("GITHUB_REPOSITORY")
    }

    release {
        title = "[$project.minecraft_version] $project.name $project.version"
        tag = buildUtils.latestTag()
    }

    assets.add(tasks.remapShadowJar.archiveFile.get())
}

publishing {
    if (project.version.toString().endsWith('-SNAPSHOT')) {
        if (!Stream.of("snapshotUrl", "mavenUser", "mavenPassword").allMatch(props::containsKey)) {
            throw new IllegalStateException("Missing properties. Make sure 'snapshotUrl', 'mavenUser' and 'mavenPassword' are set.");
        }

        repositories {
            maven {
                url = props.get('snapshotUrl')

                credentials {
                    username = props.get('mavenUser')
                    password = props.get('mavenPassword')
                }
            }
        }
    } else {
        buildUtils.setupPublishRepository(repositories, props)
    }

    publications {
        mavenJava(MavenPublication) {
            artifactId = project.archives_base_name

            // manually configure artifacts
            artifact remapShadowJar
            artifact remapSourcesJar
            artifact remapActivityJar

            pom {
                name = 'Minigame Lobby'
                description = 'A kibu plugin for managing minigame lobbies in FabricMC.'
            }
        }
    }
}